use crate::{
    alerts::{Alert, ForkProof, ForkingNotification, NetworkMessage},
    consensus,
    creation::SignedUnitWithParents,
    handle_task_termination,
    member::UnitMessage,
    units::{
        ControlHash, SignedUnit, UncheckedSignedUnit, Unit, UnitCoord, UnitStore, UnitStoreStatus,
        Validator,
    },
    Config, Data, DataProvider, FinalizationHandler, Hasher, Index, Keychain, MultiKeychain,
    NodeCount, NodeIndex, NodeMap, Receiver, Round, Sender, Signature, Signed, SpawnHandle,
    Terminator, UncheckedSigned,
};
use aleph_bft_types::Recipient;
use futures::AsyncWrite;
use futures::{
    channel::{mpsc, oneshot},
    pin_mut, AsyncRead, Future, FutureExt, StreamExt,
};
use futures_timer::Delay;
use itertools::Itertools;
use log::{debug, error, info, trace, warn};
use std::{collections::HashSet, convert::TryFrom, fmt, marker::PhantomData, time::Duration};

mod collection;

use crate::backup::{BackupLoader, BackupSaver};
#[cfg(feature = "initial_unit_collection")]
use collection::{Collection, IO as CollectionIO};
pub use collection::{NewestUnitResponse, Salt};

/// Type for incoming notifications: Runway to Consensus.
#[derive(Clone, Eq, PartialEq)]
pub(crate) enum NotificationIn<H: Hasher> {
    /// A notification carrying units. This might come either from multicast or
    /// from a response to a request. This is of no importance at this layer.
    NewUnits(Vec<Unit<H>>),
    /// Response to a request to decode parents when the control hash is wrong.
    UnitParents(H::Hash, Vec<H::Hash>),
}

/// Type for outgoing notifications: Consensus to Runway.
#[derive(Debug, Eq, PartialEq)]
pub(crate) enum NotificationOut<H: Hasher> {
    /// Notification that some units are needed but missing. The role of the Member
    /// is to fetch these unit (somehow).
    MissingUnits(Vec<UnitCoord>),
    /// Notification that Consensus has parents incompatible with the control hash.
    WrongControlHash(H::Hash),
    /// Notification that a new unit has been added to the DAG, list of decoded parents provided
    AddedToDag(H::Hash, Vec<H::Hash>),
}

/// Possible requests for information from other nodes.
pub enum Request<H: Hasher> {
    Coord(UnitCoord),
    Parents(H::Hash),
    NewestUnit(Salt),
}

pub(crate) enum Response<H: Hasher, D: Data, S: Signature> {
    Coord(UncheckedSignedUnit<H, D, S>),
    Parents(H::Hash, Vec<UncheckedSignedUnit<H, D, S>>),
    NewestUnit(UncheckedSigned<NewestUnitResponse<H, D, S>, S>),
}

pub(crate) enum RunwayNotificationOut<H: Hasher, D: Data, S: Signature> {
    /// A new unit was generated by this runway
    NewSelfUnit(UncheckedSignedUnit<H, D, S>),
    /// A new unit was generated by this runway or imported from outside and added to the DAG
    NewAnyUnit(UncheckedSignedUnit<H, D, S>),
    Request(Request<H>),
    Response(Response<H, D, S>, NodeIndex),
}

pub(crate) enum RunwayNotificationIn<H: Hasher, D: Data, S: Signature> {
    NewUnit(UncheckedSignedUnit<H, D, S>),
    Request(Request<H>, NodeIndex),
    Response(Response<H, D, S>),
}

impl<H: Hasher, D: Data, S: Signature> TryFrom<UnitMessage<H, D, S>>
    for RunwayNotificationIn<H, D, S>
{
    type Error = ();

    fn try_from(message: UnitMessage<H, D, S>) -> Result<Self, Self::Error> {
        let result = match message {
            UnitMessage::NewUnit(u) => RunwayNotificationIn::NewUnit(u),
            UnitMessage::RequestCoord(node_id, coord) => {
                RunwayNotificationIn::Request(Request::Coord(coord), node_id)
            }
            UnitMessage::RequestParents(node_id, u_hash) => {
                RunwayNotificationIn::Request(Request::Parents(u_hash), node_id)
            }
            UnitMessage::ResponseCoord(u) => RunwayNotificationIn::Response(Response::Coord(u)),
            UnitMessage::ResponseParents(u_hash, parents) => {
                RunwayNotificationIn::Response(Response::Parents(u_hash, parents))
            }
            UnitMessage::RequestNewest(node_id, salt) => {
                RunwayNotificationIn::Request(Request::NewestUnit(salt), node_id)
            }
            UnitMessage::ResponseNewest(response) => {
                RunwayNotificationIn::Response(Response::NewestUnit(response))
            }
        };
        Ok(result)
    }
}

type CollectionResponse<H, D, MK> = UncheckedSigned<
    NewestUnitResponse<H, D, <MK as Keychain>::Signature>,
    <MK as Keychain>::Signature,
>;

struct Runway<H, D, FH, MK>
where
    H: Hasher,
    D: Data,
    FH: FinalizationHandler<D>,
    MK: MultiKeychain,
{
    missing_coords: HashSet<UnitCoord>,
    missing_parents: HashSet<H::Hash>,
    store: UnitStore<H, D, MK>,
    keychain: MK,
    validator: Validator<MK>,
    alerts_for_alerter: Sender<Alert<H, D, MK::Signature>>,
    notifications_from_alerter: Receiver<ForkingNotification<H, D, MK::Signature>>,
    unit_messages_from_network: Receiver<RunwayNotificationIn<H, D, MK::Signature>>,
    unit_messages_for_network: Sender<RunwayNotificationOut<H, D, MK::Signature>>,
    responses_for_collection: Sender<CollectionResponse<H, D, MK>>,
    resolved_requests: Sender<Request<H>>,
    tx_consensus: Sender<NotificationIn<H>>,
    rx_consensus: Receiver<NotificationOut<H>>,
    ordered_batch_rx: Receiver<Vec<H::Hash>>,
    finalization_handler: FH,
    backup_units_for_saver: Sender<UncheckedSignedUnit<H, D, MK::Signature>>,
    backup_units_from_saver: Receiver<UncheckedSignedUnit<H, D, MK::Signature>>,
    signed_units_from_creation: Receiver<SignedUnitWithParents<H, D, MK>>,
    exiting: bool,
}

struct RunwayStatus<'a, H: Hasher> {
    status: UnitStoreStatus<'a>,
    missing_coords: &'a HashSet<UnitCoord>,
    missing_parents: &'a HashSet<H::Hash>,
}

impl<'a, H: Hasher> RunwayStatus<'a, H> {
    fn new(
        status: UnitStoreStatus<'a>,
        missing_coords: &'a HashSet<UnitCoord>,
        missing_parents: &'a HashSet<H::Hash>,
    ) -> Self {
        Self {
            status,
            missing_coords,
            missing_parents,
        }
    }

    fn short_report(rounds_behind: Round, missing_coords: usize) -> String {
        match (rounds_behind, missing_coords) {
            (0..=2, 0) => "healthy".to_string(),
            (0..=2, 1..) => format!("syncing - missing {missing_coords} unit(s)"),
            (3.., 0) => format!("behind by {rounds_behind} rounds"),
            _ => format!(
                "syncing - missing {missing_coords} unit(s) and behind by {rounds_behind} rounds"
            ),
        }
    }

    fn format_missing_coords(c: &[(usize, Round)]) -> String {
        c.iter()
            .sorted()
            .group_by(|(creator, _)| *creator)
            .into_iter()
            .map(|(creator, rounds)| {
                // compress consecutive rounds into one interval to shorten logs
                let mut intervals: Vec<(Round, Round)> = Vec::new();
                for (_, round) in rounds {
                    if matches!(intervals.last(), Some(interval) if interval.1 == round-1) {
                        intervals.last_mut().unwrap().1 = *round;
                    } else {
                        intervals.push((*round, *round));
                    }
                }

                let intervals_str = intervals
                    .into_iter()
                    .map(|(begin, end)| {
                        if begin == end {
                            format!("{begin}")
                        } else if begin + 1 == end {
                            format!("{begin}, {end}")
                        } else {
                            format!("[{begin}-{end}]")
                        }
                    })
                    .format(", ");

                format!("{{Creator {creator}: {intervals_str}}}")
            })
            .join(", ")
    }
}

impl<'a, H: Hasher> fmt::Display for RunwayStatus<'a, H> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Runway status report: {}",
            Self::short_report(self.status.rounds_behind(), self.missing_coords.len())
        )?;
        write!(f, ". {}", self.status)?;
        if !self.missing_coords.is_empty() {
            let v_coords: Vec<(usize, Round)> = self
                .missing_coords
                .iter()
                .map(|uc| (uc.creator().into(), uc.round()))
                .collect();
            write!(
                f,
                "; missing coords - {}",
                Self::format_missing_coords(&v_coords)
            )?;
        }
        if !self.missing_parents.is_empty() {
            write!(f, "; missing parents - {:?}", self.missing_parents)?;
        }
        write!(f, ".")?;
        Ok(())
    }
}

struct RunwayConfig<H: Hasher, D: Data, FH: FinalizationHandler<D>, MK: MultiKeychain> {
    max_round: Round,
    finalization_handler: FH,
    backup_units_for_saver: Sender<UncheckedSignedUnit<H, D, MK::Signature>>,
    backup_units_from_saver: Receiver<UncheckedSignedUnit<H, D, MK::Signature>>,
    alerts_for_alerter: Sender<Alert<H, D, MK::Signature>>,
    notifications_from_alerter: Receiver<ForkingNotification<H, D, MK::Signature>>,
    tx_consensus: Sender<NotificationIn<H>>,
    rx_consensus: Receiver<NotificationOut<H>>,
    unit_messages_from_network: Receiver<RunwayNotificationIn<H, D, MK::Signature>>,
    unit_messages_for_network: Sender<RunwayNotificationOut<H, D, MK::Signature>>,
    responses_for_collection: Sender<CollectionResponse<H, D, MK>>,
    ordered_batch_rx: Receiver<Vec<H::Hash>>,
    resolved_requests: Sender<Request<H>>,
    signed_units_from_creation: Receiver<SignedUnitWithParents<H, D, MK>>,
}

impl<H, D, FH, MK> Runway<H, D, FH, MK>
where
    H: Hasher,
    D: Data,
    FH: FinalizationHandler<D>,
    MK: MultiKeychain,
{
    fn new(config: RunwayConfig<H, D, FH, MK>, keychain: MK, validator: Validator<MK>) -> Self {
        let n_members = keychain.node_count();
        let RunwayConfig {
            max_round,
            finalization_handler,
            backup_units_for_saver,
            backup_units_from_saver,
            alerts_for_alerter,
            notifications_from_alerter,
            tx_consensus,
            rx_consensus,
            unit_messages_from_network,
            unit_messages_for_network,
            responses_for_collection,
            ordered_batch_rx,
            resolved_requests,
            signed_units_from_creation,
        } = config;
        let store = UnitStore::new(n_members, max_round);

        Runway {
            store,
            keychain,
            validator,
            missing_coords: HashSet::new(),
            missing_parents: HashSet::new(),
            resolved_requests,
            alerts_for_alerter,
            notifications_from_alerter,
            unit_messages_from_network,
            unit_messages_for_network,
            tx_consensus,
            rx_consensus,
            ordered_batch_rx,
            finalization_handler,
            backup_units_for_saver,
            backup_units_from_saver,
            responses_for_collection,
            signed_units_from_creation,
            exiting: false,
        }
    }

    fn index(&self) -> NodeIndex {
        self.keychain.index()
    }

    fn node_count(&self) -> NodeCount {
        self.keychain.node_count()
    }

    fn on_unit_message(&mut self, message: RunwayNotificationIn<H, D, MK::Signature>) {
        match message {
            RunwayNotificationIn::NewUnit(u) => {
                trace!(target: "AlephBFT-runway", "{:?} New unit received {:?}.", self.index(), &u);
                self.on_unit_received(u, false)
            }

            RunwayNotificationIn::Request(request, node_id) => match request {
                Request::Coord(coord) => {
                    trace!(target: "AlephBFT-runway", "{:?} Coords request received {:?}.", self.index(), coord);
                    self.on_request_coord(node_id, coord)
                }
                Request::Parents(u_hash) => {
                    trace!(target: "AlephBFT-runway", "{:?} Parents request received {:?}.", self.index(), u_hash);
                    self.on_request_parents(node_id, u_hash)
                }
                Request::NewestUnit(salt) => {
                    trace!(target: "AlephBFT-runway", "{:?} Newest unit request received {:?}.", self.index(), salt);
                    self.on_request_newest(node_id, salt)
                }
            },

            RunwayNotificationIn::Response(res) => match res {
                Response::Coord(u) => {
                    trace!(target: "AlephBFT-runway", "{:?} Fetch response received {:?}.", self.index(), &u);
                    self.on_unit_received(u, false)
                }
                Response::Parents(u_hash, parents) => {
                    trace!(target: "AlephBFT-runway", "{:?} Response parents received {:?}.", self.index(), u_hash);
                    self.on_parents_response(u_hash, parents)
                }
                Response::NewestUnit(response) => {
                    trace!(target: "AlephBFT-runway", "{:?} Response newest unit received from {:?}.", self.index(), response.index());
                    let res = self.responses_for_collection.unbounded_send(response);
                    if res.is_err() {
                        debug!(target: "AlephBFT-runway", "{:?} Could not send response to collection ({:?}).", self.index(), res)
                    }
                }
            },
        }
    }

    fn on_unit_received(&mut self, uu: UncheckedSignedUnit<H, D, MK::Signature>, alert: bool) {
        match self.validator.validate_unit(uu) {
            Ok(su) => {
                self.resolve_missing_coord(&su.as_signable().coord());
                if alert {
                    // Units from alerts explicitly come from forkers, and we want them anyway.
                    self.store.add_unit(su, true);
                } else {
                    self.add_unit_to_store_unless_fork(su);
                }
            }
            Err(e) => warn!(target: "AlephBFT-member", "Received unit failing validation: {}", e),
        }
    }

    fn resolve_missing_coord(&mut self, coord: &UnitCoord) {
        if self.missing_coords.remove(coord) {
            self.send_resolved_request_notification(Request::Coord(*coord));
        }
    }

    fn add_unit_to_store_unless_fork(&mut self, su: SignedUnit<H, D, MK>) {
        let full_unit = su.as_signable();
        trace!(target: "AlephBFT-member", "{:?} Adding member unit to store {:?}", self.index(), full_unit);
        if self.store.is_forker(full_unit.creator()) {
            trace!(target: "AlephBFT-member", "{:?} Ignoring forker's unit {:?}", self.index(), full_unit);
            return;
        }

        if let Some(sv) = self.store.is_new_fork(full_unit) {
            let creator = full_unit.creator();
            if !self.store.is_forker(creator) {
                // We need to mark the forker if it is not known yet.
                let proof = (su.into(), sv.into());
                self.on_new_forker_detected(creator, proof);
            }
            // We ignore this unit. If it is legit, it will arrive in some alert and we need to wait anyway.
            // There is no point in keeping this unit in any kind of buffer.
            return;
        }

        self.store.add_unit(su, false);
    }

    fn on_new_forker_detected(&mut self, forker: NodeIndex, proof: ForkProof<H, D, MK::Signature>) {
        let alerted_units = self.store.mark_forker(forker);
        let alert = self.form_alert(proof, alerted_units);
        if self.alerts_for_alerter.unbounded_send(alert).is_err() {
            warn!(target: "AlephBFT-runway", "{:?} Channel to alerter should be open", self.index());
            self.exiting = true;
        }
    }

    fn form_alert(
        &self,
        proof: ForkProof<H, D, MK::Signature>,
        units: Vec<SignedUnit<H, D, MK>>,
    ) -> Alert<H, D, MK::Signature> {
        Alert::new(
            self.index(),
            proof,
            units.into_iter().map(|signed| signed.into()).collect(),
        )
    }

    fn on_request_coord(&mut self, node_id: NodeIndex, coord: UnitCoord) {
        debug!(target: "AlephBFT-runway", "{:?} Received fetch request for coord {:?} from {:?}.", self.index(), coord, node_id);
        let maybe_su = (self.store.unit_by_coord(coord)).cloned();

        if let Some(su) = maybe_su {
            trace!(target: "AlephBFT-runway", "{:?} Answering fetch request for coord {:?} from {:?}.", self.index(), coord, node_id);
            self.send_message_for_network(RunwayNotificationOut::Response(
                Response::Coord(su.into()),
                node_id,
            ));
        } else {
            trace!(target: "AlephBFT-runway", "{:?} Not answering fetch request for coord {:?}. Unit not in store.", self.index(), coord);
        }
    }

    fn on_request_parents(&mut self, node_id: NodeIndex, u_hash: H::Hash) {
        debug!(target: "AlephBFT-runway", "{:?} Received parents request for hash {:?} from {:?}.", self.index(), u_hash, node_id);

        if let Some(p_hashes) = self.store.get_parents(u_hash) {
            let p_hashes = p_hashes.clone();
            trace!(target: "AlephBFT-runway", "{:?} Answering parents request for hash {:?} from {:?}.", self.index(), u_hash, node_id);
            let mut full_units = Vec::new();
            for hash in p_hashes.iter() {
                if let Some(fu) = self.store.unit_by_hash(hash) {
                    full_units.push(fu.clone().into());
                } else {
                    debug!(target: "AlephBFT-runway", "{:?} Not answering parents request, one of the parents missing from store.", self.index());
                    //This can happen if we got a parents response from someone, but one of the units was a fork and we dropped it.
                    //Either this parent is legit and we will soon get it in alert or the parent is not legit in which case
                    //the unit u, whose parents are beeing seeked here is not legit either.
                    //In any case, if a node added u to its Dag, then it should never reach this place in code when answering
                    //a parents request (as all the parents must be legit an thus must be in store).
                    return;
                }
            }
            self.send_message_for_network(RunwayNotificationOut::Response(
                Response::Parents(u_hash, full_units),
                node_id,
            ));
        } else {
            trace!(target: "AlephBFT-runway", "{:?} Not answering parents request for hash {:?}. Unit not in DAG yet.", self.index(), u_hash);
        }
    }

    fn on_request_newest(&mut self, requester: NodeIndex, salt: u64) {
        let unit = self.store.newest_unit(requester);
        let response = NewestUnitResponse::new(requester, self.index(), unit, salt);

        let signed_response = Signed::sign(response, &self.keychain).into_unchecked();

        if let Err(e) =
            self.unit_messages_for_network
                .unbounded_send(RunwayNotificationOut::Response(
                    Response::NewestUnit(signed_response),
                    requester,
                ))
        {
            error!(target: "AlephBFT-runway", "Unable to send response to network: {}", e);
        }
    }

    fn on_parents_response(
        &mut self,
        u_hash: H::Hash,
        parents: Vec<UncheckedSignedUnit<H, D, MK::Signature>>,
    ) {
        if self.store.get_parents(u_hash).is_some() {
            trace!(target: "AlephBFT-runway", "{:?} We got parents response but already know the parents.", self.index());
            return;
        }
        let (u_round, u_control_hash, parent_ids) = match self.store.unit_by_hash(&u_hash) {
            Some(su) => {
                let full_unit = su.as_signable();
                let parent_ids: Vec<_> = full_unit.control_hash().parents().collect();
                (
                    full_unit.round(),
                    full_unit.control_hash().combined_hash,
                    parent_ids,
                )
            }
            None => {
                trace!(target: "AlephBFT-runway", "{:?} We got parents but don't even know the unit. Ignoring.", self.index());
                return;
            }
        };

        if parent_ids.len() != parents.len() {
            warn!(target: "AlephBFT-runway", "{:?} In received parent response expected {} parents got {} for unit {:?}.", self.index(), parents.len(), parent_ids.len(), u_hash);
            return;
        }

        let mut p_hashes_node_map = NodeMap::with_size(self.node_count());
        for (i, uu) in parents.into_iter().enumerate() {
            let su = match self.validator.validate_unit(uu) {
                Ok(su) => su,
                Err(e) => {
                    warn!(target: "AlephBFT-runway", "{:?} In received parent response received a unit that does not pass validation: {}", self.index(), e);
                    return;
                }
            };
            let full_unit = su.as_signable();
            if full_unit.round() + 1 != u_round {
                warn!(target: "AlephBFT-runway", "{:?} In received parent response received a unit with wrong round.", self.index());
                return;
            }
            if full_unit.creator() != parent_ids[i] {
                warn!(target: "AlephBFT-runway", "{:?} In received parent response received a unit with wrong creator.", self.index());
                return;
            }
            let p_hash = full_unit.hash();
            let ix = full_unit.creator();
            p_hashes_node_map.insert(ix, p_hash);
            // There might be some optimization possible here to not validate twice, but overall
            // this piece of code should be executed extremely rarely.
            self.resolve_missing_coord(&su.as_signable().coord());
            self.add_unit_to_store_unless_fork(su);
        }

        if ControlHash::<H>::combine_hashes(&p_hashes_node_map) != u_control_hash {
            warn!(target: "AlephBFT-runway", "{:?} In received parent response the control hash is incorrect {:?}.", self.index(), p_hashes_node_map);
            return;
        }
        let p_hashes: Vec<_> = p_hashes_node_map.into_values().collect();
        self.store.add_parents(u_hash, p_hashes.clone());
        trace!(target: "AlephBFT-runway", "{:?} Succesful parents response for {:?}.", self.index(), u_hash);
        self.send_consensus_notification(NotificationIn::UnitParents(u_hash, p_hashes));
    }

    fn resolve_missing_parents(&mut self, u_hash: &H::Hash) {
        if self.missing_parents.remove(u_hash) {
            self.send_resolved_request_notification(Request::Parents(*u_hash));
        }
    }

    fn on_created(&mut self, signed_unit: SignedUnit<H, D, MK>) {
        debug!(target: "AlephBFT-runway", "{:?} On create notification.", self.index());
        self.store.add_unit(signed_unit, false);
    }

    fn on_alert_notification(&mut self, notification: ForkingNotification<H, D, MK::Signature>) {
        use ForkingNotification::*;
        match notification {
            Forker(proof) => {
                let forker = proof.0.index();
                if !self.store.is_forker(forker) {
                    self.on_new_forker_detected(forker, proof);
                }
            }

            Units(units) => {
                for uu in units {
                    self.on_unit_received(uu, true);
                }
            }
        }
    }

    fn on_consensus_notification(&mut self, notification: NotificationOut<H>) {
        match notification {
            NotificationOut::MissingUnits(coords) => {
                self.on_missing_coords(coords);
            }
            NotificationOut::WrongControlHash(h) => {
                self.on_wrong_control_hash(h);
            }
            NotificationOut::AddedToDag(h, p_hashes) => {
                self.store.add_parents(h, p_hashes);
                self.resolve_missing_parents(&h);
                if let Some(su) = self.store.unit_by_hash(&h).cloned() {
                    if self
                        .backup_units_for_saver
                        .unbounded_send(su.into())
                        .is_err()
                    {
                        error!(target: "AlephBFT-runway", "{:?} A unit couldn't be sent to backup: {:?}.", self.index(), h);
                    }
                } else {
                    error!(target: "AlephBFT-runway", "{:?} A unit already added to DAG is not in our store: {:?}.", self.index(), h);
                }
            }
        }
    }

    fn on_unit_backup_saved(&mut self, unit: UncheckedSignedUnit<H, D, MK::Signature>) {
        self.send_message_for_network(RunwayNotificationOut::NewAnyUnit(unit.clone()));

        if unit.as_signable().creator() == self.index() {
            trace!(target: "AlephBFT-runway", "{:?} Sending a unit {:?}.", self.index(), unit.as_signable().hash());
            self.send_message_for_network(RunwayNotificationOut::NewSelfUnit(unit));
        }
    }

    fn on_missing_coords(&mut self, mut coords: Vec<UnitCoord>) {
        trace!(target: "AlephBFT-runway", "{:?} Dealing with missing coords notification {:?}.", self.index(), coords);
        coords.retain(|coord| !self.store.contains_coord(coord));
        for coord in coords {
            if self.missing_coords.insert(coord) {
                self.send_message_for_network(RunwayNotificationOut::Request(Request::Coord(
                    coord,
                )));
            }
        }
    }

    fn on_wrong_control_hash(&mut self, u_hash: H::Hash) {
        trace!(target: "AlephBFT-runway", "{:?} Dealing with wrong control hash notification {:?}.", self.index(), u_hash);
        if let Some(p_hashes) = self.store.get_parents(u_hash) {
            // We have the parents by some strange reason (someone sent us parents
            // without us requesting them).
            let p_hashes = p_hashes.clone();
            trace!(target: "AlephBFT-runway", "{:?} We have the parents for {:?} even though we did not request them.", self.index(), u_hash);
            let notification = NotificationIn::UnitParents(u_hash, p_hashes);
            self.send_consensus_notification(notification);
        } else if self.missing_parents.insert(u_hash) {
            self.send_message_for_network(RunwayNotificationOut::Request(Request::Parents(u_hash)));
        }
    }

    fn on_ordered_batch(&mut self, batch: Vec<H::Hash>) {
        for hash in batch {
            let unit = self
                .store
                .unit_by_hash(&hash)
                .expect("Ordered units must be in store")
                .as_signable();

            self.finalization_handler.unit_finalized(
                unit.creator(),
                unit.round(),
                unit.data().clone(),
            )
        }
    }

    fn send_message_for_network(
        &mut self,
        notification: RunwayNotificationOut<H, D, MK::Signature>,
    ) {
        if self
            .unit_messages_for_network
            .unbounded_send(notification)
            .is_err()
        {
            warn!(target: "AlephBFT-runway", "{:?} unit_messages_for_network channel should be open", self.index());
            self.exiting = true;
        }
    }

    fn send_resolved_request_notification(&mut self, notification: Request<H>) {
        if self.resolved_requests.unbounded_send(notification).is_err() {
            warn!(target: "AlephBFT-runway", "{:?} resolved_requests channel should be open", self.index());
            self.exiting = true;
        }
    }

    fn send_consensus_notification(&mut self, notification: NotificationIn<H>) {
        if self.tx_consensus.unbounded_send(notification).is_err() {
            warn!(target: "AlephBFT-runway", "{:?} Channel to consensus should be open", self.index());
            self.exiting = true;
        }
    }

    fn move_units_to_consensus(&mut self) {
        let units_to_move = self
            .store
            .yield_buffer_units()
            .into_iter()
            .map(|su| su.as_signable().unit())
            .collect();
        self.send_consensus_notification(NotificationIn::NewUnits(units_to_move))
    }

    fn status_report(&self) {
        let runway_status: RunwayStatus<H> = RunwayStatus::new(
            self.store.get_status_of(self.index()),
            &self.missing_coords,
            &self.missing_parents,
        );
        info!(target: "AlephBFT-runway", "{}", runway_status);
    }

    async fn run(
        mut self,
        data_from_backup: oneshot::Receiver<Vec<UncheckedSignedUnit<H, D, MK::Signature>>>,
        mut terminator: Terminator,
    ) {
        let index = self.index();
        let data_from_backup = data_from_backup.fuse();
        pin_mut!(data_from_backup);

        let status_ticker_delay = Duration::from_secs(10);
        let mut status_ticker = Delay::new(status_ticker_delay).fuse();

        match data_from_backup.await {
            Ok(units) => {
                for unit in units {
                    self.on_unit_received(unit, false);
                }
            }
            Err(e) => {
                error!(target: "AlephBFT-runway", "{:?} Units message from backup channel closed: {:?}", index, e);
                return;
            }
        }

        debug!(target: "AlephBFT-runway", "{:?} Runway started.", index);
        loop {
            futures::select! {
                notification = self.rx_consensus.next() => match notification {
                    Some(notification) => self.on_consensus_notification(notification),
                    None => {
                        error!(target: "AlephBFT-runway", "{:?} Consensus notification stream closed.", index);
                        break;
                    }
                },

                signed_unit = self.signed_units_from_creation.next() => match signed_unit {
                    Some((signed_unit, _)) => self.on_created(signed_unit),
                    None => {
                        error!(target: "AlephBFT-runway", "{:?} Creation stream closed.", index);
                        break;
                    }
                },

                notification = self.notifications_from_alerter.next() => match notification {
                    Some(notification) => {
                        self.on_alert_notification(notification)
                    },
                    None => {
                        error!(target: "AlephBFT-runway", "{:?} Alert notification stream closed.", index);
                        break;
                    }
                },

                event = self.unit_messages_from_network.next() => match event {
                    Some(event) => self.on_unit_message(event),
                    None => {
                        error!(target: "AlephBFT-runway", "{:?} Unit message stream closed.", index);
                        break;
                    }
                },

                message = self.backup_units_from_saver.next() => match message {
                    Some(unit) => self.on_unit_backup_saved(unit),
                    None => {
                        error!(target: "AlephBFT-runway", "{:?} Saved units receiver closed.", index);
                    }
                },

                batch = self.ordered_batch_rx.next() => match batch {
                    Some(batch) => self.on_ordered_batch(batch),
                    None => {
                        error!(target: "AlephBFT-runway", "{:?} Ordered batch stream closed.", index);
                        break;
                    }
                },

                _ = &mut status_ticker => {
                    self.status_report();
                    status_ticker = Delay::new(status_ticker_delay).fuse();
                },

                _ = terminator.get_exit().fuse() => {
                    debug!(target: "AlephBFT-runway", "{:?} received exit signal", index);
                    self.exiting = true;
                }
            }
            self.move_units_to_consensus();

            if self.exiting {
                debug!(target: "AlephBFT-runway", "{:?} Runway decided to exit.", index);
                terminator.terminate_sync().await;
                break;
            }
        }

        debug!(target: "AlephBFT-runway", "{:?} Run ended.", index);
    }
}

pub(crate) struct NetworkIO<H: Hasher, D: Data, MK: MultiKeychain> {
    pub(crate) alert_messages_for_network: Sender<(NetworkMessage<H, D, MK>, Recipient)>,
    pub(crate) alert_messages_from_network: Receiver<NetworkMessage<H, D, MK>>,
    pub(crate) unit_messages_for_network: Sender<RunwayNotificationOut<H, D, MK::Signature>>,
    pub(crate) unit_messages_from_network: Receiver<RunwayNotificationIn<H, D, MK::Signature>>,
    pub(crate) resolved_requests: Sender<Request<H>>,
}

#[cfg(feature = "initial_unit_collection")]
fn initial_unit_collection<'a, H: Hasher, D: Data, MK: MultiKeychain>(
    keychain: &'a MK,
    validator: &'a Validator<MK>,
    unit_messages_for_network: &Sender<RunwayNotificationOut<H, D, MK::Signature>>,
    unit_collection_sender: oneshot::Sender<Round>,
    responses_from_runway: Receiver<CollectionResponse<H, D, MK>>,
    resolved_requests: Sender<Request<H>>,
) -> Result<impl Future<Output = ()> + 'a, ()> {
    let (collection, salt) = Collection::new(keychain, validator);
    let notification = RunwayNotificationOut::Request(Request::NewestUnit(salt));

    if let Err(e) = unit_messages_for_network.unbounded_send(notification) {
        error!(target: "AlephBFT-runway", "Unable to send the newest unit request: {}", e);
        return Err(());
    };

    let collection = CollectionIO::new(
        unit_collection_sender,
        responses_from_runway,
        resolved_requests,
        collection,
    );
    Ok(collection.run())
}

#[cfg(not(feature = "initial_unit_collection"))]
fn trivial_start(
    starting_round_sender: oneshot::Sender<Round>,
) -> Result<impl Future<Output = ()>, ()> {
    if let Err(e) = starting_round_sender.send(0) {
        error!(target: "AlephBFT-runway", "Unable to send the starting round: {}", e);
        return Err(());
    }
    Ok(async {})
}

pub struct RunwayIO<
    H: Hasher,
    D: Data,
    MK: MultiKeychain,
    W: AsyncWrite + Send + Sync + 'static,
    R: AsyncRead + Send + Sync + 'static,
    DP: DataProvider<D>,
    FH: FinalizationHandler<D>,
> {
    pub data_provider: DP,
    pub finalization_handler: FH,
    pub backup_write: W,
    pub backup_read: R,
    _phantom: PhantomData<(H, D, MK::Signature)>,
}

impl<
        H: Hasher,
        D: Data,
        MK: MultiKeychain,
        W: AsyncWrite + Send + Sync + 'static,
        R: AsyncRead + Send + Sync + 'static,
        DP: DataProvider<D>,
        FH: FinalizationHandler<D>,
    > RunwayIO<H, D, MK, W, R, DP, FH>
{
    pub fn new(
        data_provider: DP,
        finalization_handler: FH,
        backup_write: W,
        backup_read: R,
    ) -> Self {
        RunwayIO {
            data_provider,
            finalization_handler,
            backup_write,
            backup_read,
            _phantom: PhantomData,
        }
    }
}

pub(crate) async fn run<H, D, US, UL, MK, DP, FH, SH>(
    config: Config,
    runway_io: RunwayIO<H, D, MK, US, UL, DP, FH>,
    keychain: MK,
    spawn_handle: SH,
    network_io: NetworkIO<H, D, MK>,
    mut terminator: Terminator,
) where
    H: Hasher,
    D: Data,
    US: AsyncWrite + Send + Sync + 'static,
    UL: AsyncRead + Send + Sync + 'static,
    DP: DataProvider<D>,
    FH: FinalizationHandler<D>,
    MK: MultiKeychain,
    SH: SpawnHandle,
{
    let RunwayIO {
        data_provider,
        finalization_handler,
        backup_write,
        backup_read,
        _phantom: _,
    } = runway_io;

    let (tx_consensus, consensus_stream) = mpsc::unbounded();
    let (consensus_sink, rx_consensus) = mpsc::unbounded();
    let (ordered_batch_tx, ordered_batch_rx) = mpsc::unbounded();
    let (signed_units_for_runway, signed_units_from_creation) = mpsc::unbounded();

    let consensus_terminator = terminator.add_offspring_connection("AlephBFT-consensus");
    let consensus_config = config.clone();
    let consensus_spawner = spawn_handle.clone();
    let (starting_round_sender, starting_round) = oneshot::channel();

    let consensus_keychain = keychain.clone();
    let consensus_handle = spawn_handle.spawn_essential("runway/consensus", async move {
        consensus::run(
            consensus_config,
            consensus::IO {
                incoming_notifications: consensus_stream,
                outgoing_notifications: consensus_sink,
                units_for_runway: signed_units_for_runway,
                data_provider,
                ordered_batch_tx,
                starting_round,
            },
            consensus_keychain,
            consensus_spawner,
            consensus_terminator,
        )
        .await
    });
    let mut consensus_handle = consensus_handle.fuse();

    let (backup_units_for_saver, backup_units_from_runway) = mpsc::unbounded();
    let (backup_units_for_runway, backup_units_from_saver) = mpsc::unbounded();

    let backup_saver_terminator = terminator.add_offspring_connection("AlephBFT-backup-saver");
    let backup_saver_handle = spawn_handle.spawn_essential("runway/backup_saver", {
        let mut backup_saver = BackupSaver::new(
            backup_units_from_runway,
            backup_units_for_runway,
            backup_write,
        );
        async move {
            backup_saver.run(backup_saver_terminator).await;
        }
    });
    let mut backup_saver_handle = backup_saver_handle.fuse();

    let (alert_notifications_for_units, notifications_from_alerter) = mpsc::unbounded();
    let (alerts_for_alerter, alerts_from_units) = mpsc::unbounded();

    let alerter_terminator = terminator.add_offspring_connection("AlephBFT-alerter");
    let alerter_keychain = keychain.clone();
    let alert_messages_for_network = network_io.alert_messages_for_network;
    let alert_messages_from_network = network_io.alert_messages_from_network;
    let alerter_handler =
        crate::alerts::Handler::new(alerter_keychain.clone(), config.session_id());

    let mut alerter_service = crate::alerts::Service::new(
        alerter_keychain,
        crate::alerts::IO {
            messages_for_network: alert_messages_for_network,
            messages_from_network: alert_messages_from_network,
            notifications_for_units: alert_notifications_for_units,
            alerts_from_units,
        },
        alerter_handler,
    );

    let mut alerter_handle = spawn_handle
        .spawn_essential("runway/alerter", async move {
            alerter_service.run(alerter_terminator).await;
        })
        .fuse();

    let index = keychain.index();
    let validator = Validator::new(config.session_id(), keychain.clone(), config.max_round());
    let (responses_for_collection, responses_from_runway) = mpsc::unbounded();
    let (unit_collections_sender, unit_collection_result) = oneshot::channel();
    let (loaded_data_tx, loaded_data_rx) = oneshot::channel();
    let session_id = config.session_id();

    let backup_loading_handle = spawn_handle
        .spawn_essential("runway/loading", {
            let mut backup_loader = BackupLoader::new(backup_read, index, session_id);
            async move {
                backup_loader
                    .run(
                        loaded_data_tx,
                        starting_round_sender,
                        unit_collection_result,
                    )
                    .await
            }
        })
        .fuse();
    pin_mut!(backup_loading_handle);

    #[cfg(feature = "initial_unit_collection")]
    let starting_round_handle = match initial_unit_collection(
        &keychain,
        &validator,
        &network_io.unit_messages_for_network,
        unit_collections_sender,
        responses_from_runway,
        network_io.resolved_requests.clone(),
    ) {
        Ok(handle) => handle.fuse(),
        Err(_) => return,
    };
    #[cfg(not(feature = "initial_unit_collection"))]
    let starting_round_handle = match trivial_start(unit_collections_sender) {
        Ok(handle) => handle.fuse(),
        Err(_) => return,
    };
    pin_mut!(starting_round_handle);

    let runway_handle = spawn_handle
        .spawn_essential("runway", {
            let runway_config = RunwayConfig {
                finalization_handler,
                backup_units_for_saver,
                backup_units_from_saver,
                alerts_for_alerter,
                notifications_from_alerter,
                tx_consensus,
                rx_consensus,
                unit_messages_from_network: network_io.unit_messages_from_network,
                unit_messages_for_network: network_io.unit_messages_for_network,
                ordered_batch_rx,
                responses_for_collection,
                resolved_requests: network_io.resolved_requests,
                max_round: config.max_round(),
                signed_units_from_creation,
            };
            let runway_terminator = terminator.add_offspring_connection("AlephBFT-runway");
            let validator = validator.clone();
            let keychain = keychain.clone();
            let runway = Runway::new(runway_config, keychain, validator);

            async move { runway.run(loaded_data_rx, runway_terminator).await }
        })
        .fuse();
    pin_mut!(runway_handle);

    loop {
        futures::select! {
            _ = runway_handle => {
                debug!(target: "AlephBFT-runway", "{:?} Runway task terminated early.", index);
                break;
            },
            _ = alerter_handle => {
                debug!(target: "AlephBFT-runway", "{:?} Alerter task terminated early.", index);
                break;
            },
            _ = consensus_handle => {
                debug!(target: "AlephBFT-runway", "{:?} Consensus task terminated early.", index);
                break;
            },
            _ = backup_saver_handle => {
                debug!(target: "AlephBFT-runway", "{:?} Backup saving task terminated early.", index);
                break;
            },
            _ = starting_round_handle => {
                debug!(target: "AlephBFT-runway", "{:?} Starting round task terminated.", index);
            },
            _ = backup_loading_handle => {
                debug!(target: "AlephBFT-runway", "{:?} Backup loading task terminated.", index);
            },
            _ = terminator.get_exit().fuse() => {
                break;
            }
        }
    }

    debug!(target: "AlephBFT-runway", "{:?} Ending run.", index);
    terminator.terminate_sync().await;

    handle_task_termination(consensus_handle, "AlephBFT-runway", "Consensus", index).await;
    handle_task_termination(alerter_handle, "AlephBFT-runway", "Alerter", index).await;
    handle_task_termination(runway_handle, "AlephBFT-runway", "Runway", index).await;
    handle_task_termination(backup_saver_handle, "AlephBFT-runway", "BackupSaver", index).await;

    debug!(target: "AlephBFT-runway", "{:?} Runway ended.", index);
}

#[cfg(test)]
mod tests {
    use crate::runway::RunwayStatus;
    use aleph_bft_mock::Hasher64;

    #[test]
    pub fn formats_missing_coords() {
        let format_missing_coords = RunwayStatus::<Hasher64>::format_missing_coords;
        assert_eq!(format_missing_coords(&[]), "");
        assert_eq!(format_missing_coords(&[(0, 13)]), "{Creator 0: 13}");
        assert_eq!(
            format_missing_coords(&[(0, 1), (0, 2)]),
            "{Creator 0: 1, 2}"
        );
        assert_eq!(
            format_missing_coords(&[(0, 1), (0, 2), (0, 3)]),
            "{Creator 0: [1-3]}"
        );
        assert_eq!(
            format_missing_coords(&[
                (0, 1),
                (0, 3),
                (0, 4),
                (0, 5),
                (0, 6),
                (0, 9),
                (0, 10),
                (0, 12)
            ]),
            "{Creator 0: 1, [3-6], 9, 10, 12}"
        );
        assert_eq!(
            format_missing_coords(&[(1, 3), (0, 1), (1, 1), (3, 0)]),
            "{Creator 0: 1}, {Creator 1: 1, 3}, {Creator 3: 0}"
        );
    }
}
